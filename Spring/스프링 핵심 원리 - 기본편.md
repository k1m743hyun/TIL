# 스프링 핵심 원리 - 기본편


## 목차

1. 객체 지향 설계와 스프링

2. 스프링 핵심 원리 이해 1 - 예제 만들기

3. 스프링 핵심 원리 이해 2 - 객체 지향 원리 적용

4. 스프링 컨테이너와 스프링 빈

5. 싱글톤 컨테이너

6. 컴포넌트 스캔

7. 의존 관계 자동 주입

8. 빈 생명 주기 콜백

9. 빈 스코프

10. 다음으로


## 1. 객체 지향 설계와 스프링


### 목차

[1] 이야기 - 자바 진영의 추운 겨울과 스프링의 탄생

[2] 스프링이란?

[3] 좋은 객체 지향 프로그래밍이란?

[4] 좋은 객체 지향 설계의 5가지 원칙(SOLID)

[5] 객체 지향 설계와 스프링


## 2. 스프링 핵심 원리 이해 1 - 예제 만들기


### 목차

[1] 프로젝트 생성

[2] 비즈니스 요구사항과 설계

[3] 회원 도메인 설계

[4] 회원 도메인 개발

[5] 회원 도메인 실행과 테스트

[6] 주문과 할인 도메인 설계

[7] 주문과 할인 도메인 개발

[8] 주문과 할인 도메인 실행과 테스트


### [1] 프로젝트 생성


#### 사전 준비물
- Java 11
- IDE: IntelliJ or Eclipse
  

#### Spring Boot Starter에서 Spring 프로젝트 생성
- [start.spring.io](https://start.spring.io/)
  - 프로젝트 설정
    - Project: Gradle - Groovy Project
    - Language: Java
    - Spring Boot: 2.7.9
    - Project Metadata
      - group: com.k1m743hyun
      - Artifact: core-spring
      - Packaging: Jar
      - Java: 11
    - Dependencies: 선택하지 않음
  - 설정 완료 후 Generate 클릭
  - zip 파일 다운로드 완료 후 압축 해제
  - IntelliJ 실행 후 압축 해제한 디렉토리 열기


#### 동작 확인
- 기본 메인 클래스(`CoreSpringApplication.main()`) 실행


#### IntelliJ Gradle 대신에 Java 직접 실행
- 최근 IntelliJ 버전은 Gradle을 통해서 실행하는 것이 기본 설정
- 이렇게 설정되어 있으면 실행 속도가 느림
- 다음과 같이 변경하면 Java로 바로 실행해서 실행 속도가 더 빠름
    - Preferences -> Build, Execution, Deployment -> Build Tools -> Gradle
        - Build and run using: Gradle -> IntelliJ IDEA
        - Run tests using: Gradle -> IntelliJ IDEA


### [2] 비즈니스 요구사항과 설계
- 회원
  - 회원을 가입하고 조회할 수 있음
  - 회원은 일반과 VIP 두 가지 등급이 있음
  - 회원 데이터는 자체 DB를 구축하거나 외부 시스템과 연동할 수 있음 (미확정)

- 주문과 할인 정책
  - 회원은 상품을 주문할 수 있음
  - 회원 등급에 따라 할인 정책을 적용할 수 있음
  - 할인 정책은 모든 VIP에게 1000원을 할인해주는 고정 금액 할인을 적용해달라 (나중에 변경될 수 있음)
  - 할인 정책은 변경 가능성이 높음
    - 회사의 기본 할인 정책을 아직 정하지 못 했음
    - 오픈 직전까지 고민을 미루고 싶음
    - 최악의 경우 할인을 적용하지 않을 수도 있음 (미확정)

- 요구사항을 보면 회원 데이터, 할인 정책 같은 부분은 지금 결정하기 어려운 부분이 있음
- 그렇다고 이런 정책이 결정될 때까지 개발을 무기한 미룰 수 없음
- 객체 지향 설계 방법을 사용하여 인터페이스를 만들고 구현체를 언제든지 갈아끼울 수 있도록 설계해보자


### [3] 회원 도메인 설계
- 회원 도메인 요구사항
  - 회원을 가입하고 조회할 수 있음
  - 회원은 일반과 VIP 두 가지 등급이 있음
  - 회원 데이터는 자체 DB를 구축하거나 외부 시스템과 연동할 수 있음 (미확정)


#### 회원 도메인 협력 관계
![회원 도메인 협력 관계](./images/relation-of-member-domain.png)


#### 회원 클래스 다이어그램
![회원 클래스 다이어그램](./images/class-diagram-of-member-domain.png)


#### 회원 객체 다이어그램
![회원 객체 다이어그램](./images/object-diagram-of-member-domain.png)


### [4] 회원 도메인 개발


#### 회원 엔티티


##### 회원 등급
- [Grade.java](https://github.com/k1m743hyun/spring-exercise/blob/main/core-spring/src/main/java/com/k1m743hyun/corespring/member/Grade.java)


##### 회원 엔티티
- [Member.java](https://github.com/k1m743hyun/spring-exercise/blob/main/core-spring/src/main/java/com/k1m743hyun/corespring/member/Member.java)


#### 회원 저장소


##### 회원 저장소 인터페이스
- [MemberRepository.java](https://github.com/k1m743hyun/spring-exercise/blob/main/core-spring/src/main/java/com/k1m743hyun/corespring/member/MemberRepository.java)


##### 메모리 회원 저장소 구현체
- [MemoryMemberRepository.java](https://github.com/k1m743hyun/spring-exercise/blob/main/core-spring/src/main/java/com/k1m743hyun/corespring/member/MemoryMemberRepository.java)


- 데이터베이스가 아직 확정이 안되었음
  - 그래도 개발은 진행해야하니 가장 단순한 메모리 회원 저장소를 구현해서 우선 개발을 진행하자
- 참고) `HashMap`은 동시성 이슈가 발생할 수 있음
  - 이런 경우 `ConcurrentHashMap`을 사용하자


#### 회원 서비스


##### 회원 서비스 인터페이스
- [MemberService.java](https://github.com/k1m743hyun/spring-exercise/blob/main/core-spring/src/main/java/com/k1m743hyun/corespring/member/MemberService.java)


##### 회원 서비스 구현체
- [MemberServiceImpl.java](https://github.com/k1m743hyun/spring-exercise/blob/main/core-spring/src/main/java/com/k1m743hyun/corespring/member/MemoryMemberRepository.java)


### [5] 회원 도메인 실행과 테스트


#### 회원 도메인 - 회원 가입 main
- [MemberApp.java]](https://github.com/k1m743hyun/spring-exercise/blob/main/core-spring/src/main/java/com/k1m743hyun/corespring/MemberApp.java)
- 애플리케이션 로직으로 이렇게 테스트 하는 것은 좋은 방법이 아님
  - JUnit 테스트를 사용하자


#### 회원 도메인 - 회원 가입 테스트
- [CoreSpringApplicationTests.java ](https://github.com/k1m743hyun/spring-exercise/blob/main/core-spring/src/test/java/com/k1m743hyun/corespring/CoreSpringApplicationTests.java)


#### 회원 도메인 설계의 문제점
- 이 코드의 설계 상 문제점은 무엇일까?
  - 다른 저장소로 변경할 때 OCP 원칙을 잘 준수하는가?
  - DIP를 잘 지키고 있는가?
  - 의존 관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있음


### [6] 주문과 할인 도메인 설계
- 주문과 할인 정책
  - 회원은 상품을 주문할 수 있음
  - 회원 등급에 따라 할인 정책을 적용할 수 있음
  - 할인 정책은 모든 VIP에게 1000원을 할인해주는 고정 금액 할인을 적용해달라 (나중에 변경될 수 있음)
  - 할인 정책은 변경 가능성이 높음
    - 회사의 기본 할인 정책을 아직 정하지 못 했음
    - 오픈 직전까지 고민을 미루고 싶음
    - 최악의 경우 할인을 적용하지 않을 수도 있음 (미확정)


#### 주문 도메인 협력, 역할, 책임
![주문 도메인 협력, 역할, 책임](./images/relation-of-order-domain.png)
- (1) 주문 생성
  - 클라이언트는 주문 서비스에 주문 생성을 요청
- (2) 회원 조회
  - 할인을 위해서는 회원 등급이 필요
  - 그래서 주문 서비스는 회원 저장소에서 회원을 조회함
- (3) 할인 적용
  - 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임함
- (4) 주문 결과 반환
  - 주문 서비스는 할인 결과를 포함한 주문 결과를 반환함
- 참고) 실제로는 주문 데이터를 DB에 저장하겠지만, 예제가 너무 복잡해질 수 있어서 생략하고, 단순히 주문 결과를 반환함


#### 주문 도메인 전체
![주문 도메인 전체](./images/overall-of-order-domain.png)
- *역할과 구현을 분리*해서 자유롭게 구현 객체를 조립할 수 있게 설계
  - 덕분에 회원 저장소는 물론이고, 할인 정책도 유연하게 변경할 수 있음


#### 주문 도메인 클래스 다이어그램
![주문 도메인 클래스 다이어그램](./images/class-diagram-of-order-domain.png)


#### 주문 도메인 객체 다이어그램 1
![주문 도메인 객체 다이어그램 1](./images/class-diagram-of-order-domain%20(1).png)
- 회원을 메모리에서 조회하고, 정액 할인 정책(고정 금액)을 지원해도 주문 서비스를 변경하지 않아도 됨
- 역할들의 협력 관계를 그대로 재사용할 수 있음


#### 주문 도메인 객체 다이어그램 2
![주문 도메인 객체 다이어그램 2](./images/class-diagram-of-order-domain%20(2).png)
- 회원을 메모리가 아닌 실제 DB에서 조회하고, 정률 할인 정책(주문 금액에 따라 % 할인)을 지원해도 주문 서비스를 변경하지 않아도 됨
- 협력 관계를 그대로 재사용할 수 있음


### [7] 주문과 할인 도메인 개발


#### 할인 정책 인터페이스
- [DiscountPolicy.java](https://github.com/k1m743hyun/spring-exercise/blob/main/core-spring/src/main/java/com/k1m743hyun/corespring/discount/DiscountPolicy.java)


#### 정액 할인 정책 구현체
- [FixDiscountPolicy.java](https://github.com/k1m743hyun/spring-exercise/blob/main/core-spring/src/main/java/com/k1m743hyun/corespring/discount/FixDiscountPolicy.java)
- VIP면 1000원 할인, 아니면 할인 없음

#### 주문 엔티티
- [Order.java](https://github.com/k1m743hyun/spring-exercise/blob/main/core-spring/src/main/java/com/k1m743hyun/corespring/order/Order.java)


#### 주문 서비스 인터페이스
- [OrderService.java](https://github.com/k1m743hyun/spring-exercise/blob/main/core-spring/src/main/java/com/k1m743hyun/corespring/order/OrderService.java)


#### 주문 서비스 구현체
- [OrderServiceImpl.java](https://github.com/k1m743hyun/spring-exercise/blob/main/core-spring/src/main/java/com/k1m743hyun/corespring/order/OrderServiceImpl.java)
- 주문 생성 요청이 오면, 회원 정보를 조회하고, 할인 정책을 적용한 다음 주문 객체를 생성해서 반환함
- **메모리 회원 리포지토리와, 고정 금액 할인 정책을 구현체로 생성함**


### [8] 주문과 할인 도메인 실행과 테스트


#### 주문과 할인 정책 실행
- [OrderApp.java](https://github.com/k1m743hyun/spring-exercise/blob/main/core-spring/src/main/java/com/k1m743hyun/corespring/OrderApp.java)
- 애플리케이션 로직으로 이렇게 테스트하는 것은 좋은 방법은 아님
  - JUnit 테스트를 사용하자


#### 주문과 할인 정책 테스트
- [OrderServiceTest.java](https://github.com/k1m743hyun/spring-exercise/blob/main/core-spring/src/test/java/com/k1m743hyun/corespring/order/OrderServiceTest.java)